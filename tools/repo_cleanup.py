#!/usr/bin/env python3
"""Repository cleanup utility.

Moves legacy Python modules into ``archive/legacy`` while keeping the
``hsi_fm`` package as the canonical source of code. The script is designed to
be idempotent and records all moves in ``MIGRATION.md``.
"""
from __future__ import annotations

import argparse
import shutil
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Sequence


@dataclass
class MoveRecord:
    source: Path
    destination: Path
    note: str = ""

    def to_row(self, root: Path) -> str:
        src_rel = self.source.relative_to(root)
        dst_rel = self.destination.relative_to(root)
        note = self.note.replace("|", "/")
        return f"| `{src_rel}` | `{dst_rel}` | {note} |"


ROOT = Path(__file__).resolve().parents[1]
PACKAGE_DIR = ROOT / "hsi_fm"
ARCHIVE_DIR = ROOT / "archive" / "legacy"
MIGRATION_FILE = ROOT / "MIGRATION.md"

# Items that should remain in the repository root.
ROOT_ALLOWLIST = {
    "hsi_fm",
    "archive",
    "tools",
    "README.md",
    "LICENSE",
    "pyproject.toml",
    ".gitignore",
    ".pre-commit-config.yaml",
    "Makefile",
    ".github",
    "MIGRATION.md",
}


def _contains_python_files(path: Path) -> bool:
    if path.is_file():
        return path.suffix == ".py"
    if not path.exists():
        return False
    for child in path.rglob("*.py"):
        if child.is_file():
            return True
    return False


def _rename_with_suffix(path: Path, suffix: str) -> Path:
    if path.is_dir():
        return path.with_name(f"{path.name}{suffix}")
    stem = path.stem
    return path.with_name(f"{stem}{suffix}{path.suffix}")


def _planned_moves() -> List[MoveRecord]:
    moves: List[MoveRecord] = []
    ARCHIVE_DIR.mkdir(parents=True, exist_ok=True)
    for entry in ROOT.iterdir():
        if entry.name in ROOT_ALLOWLIST:
            continue
        if entry.name.startswith(".") and entry.name not in {".github", ".git"}:
            # Skip other dot directories/files.
            continue
        if not _contains_python_files(entry):
            continue
        if entry.is_relative_to(ARCHIVE_DIR):  # type: ignore[attr-defined]
            continue
        destination = ARCHIVE_DIR / entry.name
        note = ""
        if entry.is_file():
            sibling = PACKAGE_DIR / entry.name
        else:
            sibling = PACKAGE_DIR / entry.name
        if sibling.exists():
            destination = _rename_with_suffix(destination, "_old")
            note = "Renamed to avoid clashing with hsi_fm version"
        moves.append(MoveRecord(entry, destination, note))
    return sorted(moves, key=lambda rec: rec.source.name)


def _execute_moves(moves: Sequence[MoveRecord], dry_run: bool) -> None:
    for record in moves:
        print(f"[{'DRY' if dry_run else 'MOVE'}] {record.source} -> {record.destination}")
        if dry_run:
            continue
        record.destination.parent.mkdir(parents=True, exist_ok=True)
        if record.destination.exists():
            if record.destination.is_dir():
                shutil.rmtree(record.destination)
            else:
                record.destination.unlink()
        shutil.move(str(record.source), str(record.destination))


def _collect_import_summary(modules: Iterable[str]) -> List[str]:
    summary_lines: List[str] = []
    py_files = [p for p in ROOT.rglob("*.py") if "archive/legacy" not in str(p)]
    for module in sorted(set(modules)):
        hits: List[str] = []
        patterns = (f"from {module}", f"import {module}")
        for py_file in py_files:
            try:
                text = py_file.read_text(encoding="utf-8")
            except UnicodeDecodeError:
                continue
            for idx, line in enumerate(text.splitlines(), start=1):
                if any(pattern in line for pattern in patterns):
                    hits.append(f"- `{py_file.relative_to(ROOT)}:{idx}` :: {line.strip()}")
                    if len(hits) >= 5:
                        break
            if len(hits) >= 5:
                break
        if hits:
            summary_lines.append(f"### Imports referencing `{module}`")
            summary_lines.extend(hits)
    return summary_lines


def _module_names_from_moves(moves: Sequence[MoveRecord]) -> List[str]:
    modules: List[str] = []
    for record in moves:
        rel = record.source.relative_to(ROOT)
        if rel.suffix == ".py":
            modules.append(rel.with_suffix("").as_posix().replace("/", "."))
        else:
            modules.append(rel.as_posix().replace("/", "."))
    return modules


def _write_migration_report(moves: Sequence[MoveRecord], import_summary: Sequence[str]) -> None:
    lines: List[str] = ["# Repository Migration Log", ""]
    lines.append("This file is auto-generated by `tools/repo_cleanup.py`. Do not edit manually.")
    lines.append("")
    lines.append("## Moves")
    lines.append("")
    if moves:
        lines.append("| From | To | Notes |")
        lines.append("| --- | --- | --- |")
        for record in moves:
            lines.append(record.to_row(ROOT))
    else:
        lines.append("No moves were necessary.")
    lines.append("")
    lines.append("## Legacy import references")
    lines.append("")
    if import_summary:
        lines.extend(import_summary)
    else:
        lines.append("No legacy imports detected.")
    lines.append("")
    lines.append("## TODOs")
    lines.append("")
    lines.append("- [ ] Review archived modules in `archive/legacy` for potential deletion after verifying parity.")
    lines.append("- [ ] Update any remaining imports to use the `hsi_fm` package exclusively.")
    MIGRATION_FILE.write_text("\n".join(lines), encoding="utf-8")


def main(argv: Sequence[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="Quarantine legacy modules under archive/legacy")
    parser.add_argument("--dry-run", action="store_true", help="Print planned moves without modifying the repo")
    args = parser.parse_args(argv)

    moves = _planned_moves()
    _execute_moves(moves, dry_run=args.dry_run)

    if args.dry_run:
        print("Dry run complete. No files were moved.")
        return 0

    modules = _module_names_from_moves(moves)
    import_summary = _collect_import_summary(modules)
    _write_migration_report(moves, import_summary)

    print(f"Wrote migration report to {MIGRATION_FILE.relative_to(ROOT)}")
    return 0


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())
